# 后端技术栈

做好后端程序员需要的技术

[TOC]



## 一、Java SE

### 面向对象

#### HashMap

1. 简介

**这个东西挺有用的，运行速度快，什么东西都能存，这是我在实习过程中发现的，所有项目都在用**

HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。

HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。

HashMap 是无序的，即不会记录插入的顺序。

HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。

HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。

```java
Map<Integer, String> map1 = Map.of(1, "apple", 2, "banana");
```

大概就这么个东西，很多用法，还有比如map套map。

2. 初始化及添加数据

```java
// 创建 HashMap 对象 Sites
HashMap<Integer, String> Sites = new HashMap<Integer, String>();
// 添加键值对
Sites.put(1, "Google");
Sites.put(2, "Runoob");
Sites.put(3, "Taobao");
Sites.put(4, "Zhihu");
System.out.println(Sites);
```

大概就这样，执行打印结果如下

```java
{1=Google, 2=Runoob, 3=Taobao, 4=Zhihu}
```

3. 访问数据

```java
System.out.println(Sites.get(3));
```

结果如下

```java
Taobao
```

4. 删除元素

```java
Sites.remove(4);
System.out.println(Sites);
```

结果如下

```java
{1=Google, 2=Runoob, 3=Taobao}
```

删除所有键值对应关系，则用clear

```java
Sites.clear();
```

输出`{}`空map

5. 计算大小

```java
Sites.size();
```

6. 迭代

```java
// 引入 HashMap 类      
import java.util.HashMap;

public class RunoobTest {
    public static void main(String[] args) {
        // 创建 HashMap 对象 Sites
        HashMap<Integer, String> Sites = new HashMap<Integer, String>();
        // 添加键值对
        Sites.put(1, "Google");
        Sites.put(2, "Runoob");
        Sites.put(3, "Taobao");
        Sites.put(4, "Zhihu");
        // 输出 key 和 value
        for (Integer i : Sites.keySet()) {
            System.out.println("key: " + i + " value: " + Sites.get(i));
        }
        // 返回所有 value 值
        for(String value: Sites.values()) {
          // 输出每一个value
          System.out.print(value + ", ");
        }
    }
}
```

输出如下

```java
key: 1 value: Google
key: 2 value: Runoob
key: 3 value: Taobao
key: 4 value: Zhihu
Google, Runoob, Taobao, Zhihu,
```

7. 其他方法（这才是重点）

| [clear()](https://www.runoob.com/java/java-hashmap-clear.html) |                 删除 hashMap 中的所有键/值对                 |
| :----------------------------------------------------------- | :----------------------------------------------------------: |
| [clone()](https://www.runoob.com/java/java-hashmap-clone.html) |                       复制一份 hashMap                       |
| [isEmpty()](https://www.runoob.com/java/java-hashmap-isempty.html) |                    判断 hashMap 是否为空                     |
| [size()](https://www.runoob.com/java/java-hashmap-size.html) |                 计算 hashMap 中键/值对的数量                 |
| [put()](https://www.runoob.com/java/java-hashmap-put.html)   |                  将键/值对添加到 hashMap 中                  |
| [putAll()](https://www.runoob.com/java/java-hashmap-putall.html) |                将所有键/值对添加到 hashMap 中                |
| [putIfAbsent()](https://www.runoob.com/java/java-hashmap-putifabsent.html) | 如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。 |
| [remove()](https://www.runoob.com/java/java-hashmap-remove.html) |             删除 hashMap 中指定键 key 的映射关系             |
| [containsKey()](https://www.runoob.com/java/java-hashmap-containskey.html) |      检查 hashMap 中是否存在指定的 key 对应的映射关系。      |
| [containsValue()](https://www.runoob.com/java/java-hashmap-containsvalue.html) |     检查 hashMap 中是否存在指定的 value 对应的映射关系。     |
| [replace()](https://www.runoob.com/java/java-hashmap-replace.html) |          替换 hashMap 中是指定的 key 对应的 value。          |
| [replaceAll()](https://www.runoob.com/java/java-hashmap-replaceall.html) |  将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。   |
| [get()](https://www.runoob.com/java/java-hashmap-get.html)   |                  获取指定 key 对应对 value                   |
| [getOrDefault()](https://www.runoob.com/java/java-hashmap-getordefault.html) | 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 |
| [forEach()](https://www.runoob.com/java/java-hashmap-foreach.html) |           对 hashMap 中的每个映射执行指定的操作。            |
| [entrySet()](https://www.runoob.com/java/java-hashmap-entryset.html) |          返回 hashMap 中所有映射项的集合集合视图。           |
| [keySet](https://www.runoob.com/java/java-hashmap-keyset.html)() |           返回 hashMap 中所有 key 组成的集合视图。           |
| [values()](https://www.runoob.com/java/java-hashmap-values.html) |             返回 hashMap 中存在的所有 value 值。             |
| [merge()](https://www.runoob.com/java/java-hashmap-merge.html) |                   添加键值对到 hashMap 中                    |
| [compute()](https://www.runoob.com/java/java-hashmap-compute.html) |            对 hashMap 中指定 key 的值进行重新计算            |
| [computeIfAbsent()](https://www.runoob.com/java/java-hashmap-computeifabsent.html) | 对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中 |
| [computeIfPresent()](https://www.runoob.com/java/java-hashmap-computeifpresent.html) | 对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 |

#### Enum类（枚举类）

```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```

目前正在研究

------

## 二、部分算法

### 1. 确定两个字符串是否为字母异位词

```Java
public boolean isAnagram(String a, String b) {
        if (a.length() != b.length()) {
            return false;
        }
        int[] countA = new int[26];
        int[] countB = new int[26];
        for (int i = 0; i < a.length(); i++) {
            countA[a.charAt(i) - 'a']++;
        }
        for (int i = 0; i < b.length(); i++) {
            countB[b.charAt(i) - 'a']++;
        }
        if (Arrays.equals(countA, countB)) {
            return true;
        }else {
            return false;
        }
    }
```

注意这个东西`int[] countA = new int[26];`，这个东西类似一个字母表，26位对应26个字母，一种字母每出现一次，就在对应位置+1。

**`a.charAt(i) - 'a'`这个东西很巧妙**，用一个小写字母减去a，就得到了这个字母的序号。因为'a'实际上在ASCII码里是97，'b'是98、'c'是99······以此类推，a-a=0，b-a=1，c-a=2······。

所以，`int[] countA = new int[26];`这个东西记录了每种字母出现的次数，如果这个数组相同，那么这两个字符串就是字母异位词。



------

## 三、Maven

阿里云镜像

```xml
  <mirrors>
    <mirror>
      <id>aliyunMaven</id>
      <mirrorOf>*</mirrorOf>
      <name>阿里云公共仓库</name>
      <url>https://maven.aliyun.com/repository/public</url>
  	</mirror>
  </mirrors>
```



------

## 四、Spring 

链接：[Spring Home](https://start.spring.io/)

### Spring Boot

链接：[Spring Boot Initializr](https://start.spring.io/)

开发项目基本用这个

Spring Boot帮助你创建可以运行的独立的、基于Spring的生产级应用程序。 我们对Spring平台和第三方库采取了有主见的观点，这样你就能以最少的麻烦开始工作。 大多数Spring Boot应用程序只需要很少的Spring配置。

你可以使用Spring Boot来创建Java应用程序，可以通过使用 `java -jar` 或更传统的war部署来启动。

我们的主要目标是。

- 为所有的Spring开发提供一个根本性的更快、更广泛的入门体验。
- 开箱即用，但随着需求开始偏离默认值，请迅速摆脱困境。
- 提供一系列大类项目常见的非功能特性（如嵌入式服务器、安全、度量、健康检查和外部化配置）。
- 绝对没有代码生成（当不以原生镜像为目标时），也不要求XML配置。

### Spring MVC

### Spring Cloud

------

## 五、MyBatis

这是ORM框架（Object Relational Mapping）

**MyBatis 的本质就是 Java 对数据库的操作；hiberbate是对实体类进行操作**

[详细教程链接](https://blog.csdn.net/qq_43750301/article/details/124348936)

实习期间学到一个很有用的东西，双数据源，用jdbcTemplate操作sql语句或者mybatis操作都可以

这个可以在sdk中发挥作用，即sdk操作一个数据库，引入方操作另一个数据库，非常实用。今天（2024-08-24 19:29 Saturday）终于完美解决了这个问题，以前总是其中一个数据库覆盖另一个，解决方案是在sdk和引入方分别配置一个配置类@Configuration，并且把其中一个表上注解@Primary。今天主要是在sdk和引入方用mybatis-plus实现了双数据源，详情还需进一步研究。

**Mybatis增强工具MyBatis-plus**

这个很不错，操作比jdbcTemplate简单很多，可以自由设定查询条件，可返回对象，也可以返回对象列表

**代码生成器Mybatis-plus-generator**

这个工具还需进一步研究。

可以一键生成dao层的mapper.java、service层的IService（理论上）、mapper.xml文件。



------

## 六、数据库

### MySQL

MySQL 是最流行的<u>**关系型数据库**</u>管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。

root -> 123456



### Redis

REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的<u>**非关系型数据库**</u>。

写一个配置类

root -> null



------

## 七、SLF4J日志

注解@Slf4j



------

## 八、Git熟练使用

刚创建库的时候，记得先把远程库中的东西拉到本地，然后再开始push

git clone [url] ： 这是把url中的项目克隆到当前路径

------

## 九、JWT

这个不清楚，有待学习

